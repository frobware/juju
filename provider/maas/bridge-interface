#!/bin/bash

passwd -d ubuntu

set -u

PROGNAME=$(basename $0)
SCRIPTPATH="$(cd $(dirname "${BASH_SOURCE[0]}") && pwd -P)"

: ${BACKUP_INPUT_FILE_OPTIONS:=--backup=numbered}
: ${BRIDGE_PREFIX:="br-"}
: ${CHECK_PACKAGES_INSTALLED:=1}
: ${DEBUG:=0}
: ${DRY_RUN:=}
: ${IFUPDOWN_VERBOSE:=}
: ${NEW_ENI_FILE:=}
: ${PREFERRED_PYTHON_BINARY:=}
: ${LOG_STATE:=1}

[ $DEBUG -eq 1 ] && set -x

log_state() {
    [ $LOG_STATE -eq 1 ] || return 0
    local msg=$1
    local filename=$2
    echo "START: $msg"
    cat $filename
    ip link show up
    brctl show
    ip route
    echo "END: $msg"
    return 0
}

if [ $CHECK_PACKAGES_INSTALLED -eq 1 ]; then
    if ! [ -x "$(command -v brctl)" ]; then
	echo 'error: brctl is not installed; please install package bridge-utils' >&2
	exit 1
    fi
    if ! [ -x "$(command -v ifenslave)" ]; then
	echo 'error: ifenslave is not installed; please install package ifenslave' >&2
	exit 1
    fi
fi

if [ $# -lt 2 ]; then
    echo "usage: $PROGNAME: <interface-file> <interface>..."
    exit 2
fi

# For ubuntu series < xenial we prefer python2 over python3 as we
# don't want to invalidate lots of testing against known cloud-image
# contents.
#
# A summary of Ubuntu releases and python inclusion in the default
# install of Ubuntu Server is as follows:
#
# 12.04 precise:  python 2 (2.7.3)
# 14.04 trusty:   python 2 (2.7.5) and python3 (3.4.0)
# 14.10 utopic:   python 2 (2.7.8) and python3 (3.4.2)
# 15.04 vivid:    python 2 (2.7.9) and python3 (3.4.3)
# 15.10 wily:     python 2 (2.7.9) and python3 (3.4.3)
# 16.04 xenial:   python 3 only (3.5.1)
#
# going forward:  python 3 only

if [ -z "$PREFERRED_PYTHON_BINARY" ]; then
    if [ -x "$(command -v python2)" ]; then
	PREFERRED_PYTHON_BINARY=/usr/bin/python2
    elif [ -x "$(command -v python3)" ]; then
	PREFERRED_PYTHON_BINARY=/usr/bin/python3
    elif [ -x "$(command -v python)" ]; then
	PREFERRED_PYTHON_BINARY=/usr/bin/python
    fi
fi

if ! [ -x "$(command -v $PREFERRED_PYTHON_BINARY)" ]; then
    echo "error: $PREFERRED_PYTHON_BINARY not executable, or not a command" >&2
    exit 1
fi

orig_file="$1"; shift

if [ -z "$NEW_ENI_FILE" ]; then
    NEW_ENI_FILE=$(mktemp -t)
#    trap 'rm -f "$NEW_ENI_FILE"' EXIT
fi

$DRY_RUN $PREFERRED_PYTHON_BINARY "$SCRIPTPATH/add-bridge.py" --output="$NEW_ENI_FILE" --bridge-prefix="$BRIDGE_PREFIX" "$orig_file" "$@"

if [ $? -ne 0 ]; then
    echo "error: failed to add bridge stanzas to $orig_file"
    exit 1
fi

# Any error from here should be immediately fatal.
# set -e

if cmp -s "$orig_file" "$NEW_ENI_FILE"; then
    echo "nothing to bridge, or already bridged."
    exit 0
fi

log_state "**** Original configuration" $orig_file
$DRY_RUN ifdown $IFUPDOWN_VERBOSE --exclude=lo --interfaces="$orig_file" "$@"

if grep -q 'bond-' "$orig_file"; then
    echo "sleeping to work around https://bugs.launchpad.net/ubuntu/+source/ifenslave/+bug/1269921"
    echo "sleeping to work around https://bugs.launchpad.net/juju/+bug/1594855"
    $DRY_RUN sleep ${BOND_SLEEP_DURATION:-10}
fi

declare -a bridge_ifnames=()

for i in "$@"; do
    bridge_ifnames=(${bridge_ifnames[@]+"${bridge_ifnames[@]}"} "${BRIDGE_PREFIX}${i}")
done

$DRY_RUN ifup $IFUPDOWN_VERBOSE --exclude=lo --interfaces="$NEW_ENI_FILE" -a

if [ $? -eq 0 ]; then
    $DRY_RUN chmod 644 "$NEW_ENI_FILE"
    $DRY_RUN cp $BACKUP_INPUT_FILE_OPTIONS "$NEW_ENI_FILE" "$orig_file"
    # log_state "**** New configuration" "$NEW_ENI_FILE"
else
    # If the previous ifup fails on the new file we want to raise the
    # original interface(s) against the definitions in the original
    # file.
    $DRY_RUN ifup --force $IFUPDOWN_VERBOSE --interfaces="$orig_file" -a
fi
